---
**Meta信息**
- **创建时间**: 2025-01-06
- **更新时间**: 2025-01-06
- **项目**: DJI Edge SDK 大文件下载中断处理优化
- **配置文件**: `/home/celestial/dev/esdk-test/Edge-SDK/celestial_nasops/unified_config.json`
- **SSH配置**: `/home/celestial/.ssh/config` (host: nas-edge)
- **执行范围**: 阶段一 - Dock→Edge传输可靠性优化
- **预计工期**: 2-3周
---

# 大文件下载中断处理执行计划

## 执行概览

### 项目目标
解决DJI Edge SDK系统中大文件传输的核心可靠性问题，实现从当前<70%成功率提升至≥95%，内存使用从文件大小级别降低至固定≤100MB。

### 执行策略
采用**渐进式重构**策略，保持系统稳定性的同时逐步引入新功能：
1. **基础设施先行**: 数据库、配置、工具类
2. **核心逻辑重构**: 分块传输管理器
3. **系统集成**: 与现有DockInfoManager集成
4. **监控完善**: 恢复机制和监控系统

### 风险控制
- 每个步骤都有**回滚方案**
- 关键修改点有**A/B测试**能力
- 完整的**单元测试**和**集成测试**

## 详细执行计划

### 第一阶段：基础设施建设 (3-4天)

#### 步骤1.1：数据库架构设计与实现
**优先级**: 🔴 高 | **预计时间**: 1天 | **风险**: 低

**当前状态分析**:
```cpp
// 现有系统 - dock_info_manager.cc (第156行)
void DockInfoManager::OnMediaFileUpdate(const MediaFileInfo& file_info) {
    // 当前实现：直接全量下载到内存vector
    std::vector<uint8_t> file_data;
    auto ret = media_files_reader_->ReadMediaFile(file_info.file_path, file_data);
    // 问题：大文件导致内存溢出
}
```

**改动内容**:
1. **新增数据库文件**: `celestial_works/dock_transfer_status.db`
2. **创建数据库管理类**: `celestial_works/src/transfer_status_db.h/cc`

**核心改动原因**:
- **Why**: 现有系统无状态持久化，进程重启后丢失所有传输进度
- **What**: 引入SQLite数据库存储传输状态和分块信息
- **How**: 设计支持断点续传的数据库schema

**实现代码**:
```cpp
// 新增文件: src/transfer_status_db.h
class TransferStatusDB {
public:
    bool Initialize(const std::string& db_path);
    int CreateTransferTask(const MediaFileInfo& file_info);
    bool UpdateChunkStatus(int task_id, int chunk_index, const std::string& status);
    std::vector<TransferTask> GetIncompleteTransfers();
    
private:
    sqlite3* db_;
    std::mutex db_mutex_;  // 线程安全保护
};
```

**验收标准**:
- [ ] 数据库文件成功创建
- [ ] 基本CRUD操作测试通过
- [ ] 并发访问测试通过
- [ ] 数据库schema版本管理就绪

**回滚方案**: 删除数据库文件，不影响现有系统

---

#### 步骤1.2：配置管理扩展
**优先级**: 🔴 高 | **预计时间**: 0.5天 | **风险**: 低

**当前状态分析**:
```json
// 现有配置 - unified_config.json
{
  // 缺少传输相关配置
  "media_finding_daemon": { ... },
  "storage_manager": { ... }
}
```

**改动内容**:
在`unified_config.json`中新增`dock_transfer_config`节点

**核心改动原因**:
- **Why**: 硬编码参数难以调优，不同环境需要不同配置
- **What**: 统一配置管理，支持运行时调整
- **How**: 扩展现有配置文件，保持一致性

**配置项设计**:
```json
{
  "dock_transfer_config": {
    "chunk_size_bytes": 1048576,        // 1MB (遵循大疆建议)
    "max_concurrent_chunks": 3,         // 并发控制
    "max_retry_attempts": 3,            // 重试策略
    "heartbeat_interval_ms": 10000,     // 心跳监控
    "temp_download_path": "./celestial_works/temp_downloads",
    "enable_integrity_validation": true  // 完整性校验开关
  }
}
```

**验收标准**:
- [ ] 配置文件格式验证通过
- [ ] 配置加载器测试通过
- [ ] 默认值和边界值测试通过

---

#### 步骤1.3：工具类库实现
**优先级**: 🟡 中 | **预计时间**: 1天 | **风险**: 低

**改动内容**:
1. **文件完整性验证器**: `celestial_works/src/file_integrity_validator.h/cc`
2. **传输统计收集器**: `celestial_works/src/transfer_statistics.h/cc`
3. **错误处理器**: `celestial_works/src/transfer_error_handler.h/cc`

**核心改动原因**:
- **Why**: 现有系统缺乏完整性验证和错误处理机制
- **What**: 提供可复用的工具类，支持MD5校验和统计收集
- **How**: 独立模块设计，便于测试和维护

**关键实现**:
```cpp
// 文件完整性验证器
class FileIntegrityValidator {
public:
    std::string CalculateChunkMD5(const std::vector<uint8_t>& chunk_data);
    bool ValidateChunk(const std::vector<uint8_t>& chunk, const std::string& expected_md5);
    bool ValidateFileSize(const std::string& file_path, size_t expected_size);
};
```

**验收标准**:
- [ ] MD5计算准确性测试通过
- [ ] 大文件分块校验测试通过
- [ ] 性能基准测试达标 (<10ms/MB)

---

### 第二阶段：核心传输逻辑重构 (5-6天)

#### 步骤2.1：分块传输管理器设计
**优先级**: 🔴 高 | **预计时间**: 2天 | **风险**: 中

**当前状态分析**:
```cpp
// 现有问题代码 - dock_info_manager.cc
void DockInfoManager::OnMediaFileUpdate(const MediaFileInfo& file_info) {
    std::vector<uint8_t> file_data;  // 问题：全量内存分配
    auto ret = media_files_reader_->ReadMediaFile(file_info.file_path, file_data);
    
    if (ret == ErrorCode::kOk) {
        // 问题：无中断恢复机制
        SaveToLocalFile(file_info.file_name, file_data);
    }
}
```

**改动内容**:
创建`ChunkedTransferManager`类，替换现有的一次性下载逻辑

**核心改动原因**:
- **Why**: 现有全量下载导致大文件内存溢出，无法处理网络中断
- **What**: 实现1MB分块下载，支持断点续传和并发控制
- **How**: 状态机驱动的分块传输，每块独立验证和重试

**架构设计**:
```cpp
class ChunkedTransferManager {
public:
    struct TransferConfig {
        size_t chunk_size = 1024 * 1024;  // 1MB (大疆建议)
        int max_concurrent_chunks = 3;
        int max_retry_attempts = 3;
        std::string temp_path;
    };
    
    ErrorCode StartTransfer(const MediaFileInfo& file_info);
    ErrorCode ResumeTransfer(const std::string& file_path);
    TransferProgress GetProgress(const std::string& file_path);
    
private:
    void DownloadChunk(int task_id, int chunk_index);
    bool ValidateAndSaveChunk(const ChunkData& chunk);
    void HandleChunkFailure(int task_id, int chunk_index, const std::string& error);
};
```

**状态机设计**:
```
[文件发现] → [创建任务] → [分块计算] → [并发下载] → [完整性验证] → [文件合并] → [清理临时文件]
     ↓            ↓           ↓           ↓            ↓            ↓
  [数据库记录] [分块状态] [进度更新] [错误重试]   [校验失败]   [传输完成]
```

**验收标准**:
- [ ] 1MB分块下载功能正常
- [ ] 并发控制机制有效 (最多3个并发)
- [ ] 内存使用稳定在100MB以内
- [ ] 分块完整性验证100%准确

---

#### 步骤2.2：断点续传机制实现
**优先级**: 🔴 高 | **预计时间**: 2天 | **风险**: 中

**当前状态分析**:
现有系统无任何断点续传能力，网络中断或进程重启后必须重新开始

**改动内容**:
1. **传输状态恢复**: 系统启动时扫描未完成任务
2. **分块验证**: 检查已下载分块的完整性
3. **智能续传**: 从中断点继续下载

**核心改动原因**:
- **Why**: 大文件传输时间长，中断重传浪费带宽和时间
- **What**: 实现分块级别的断点续传，最小化重传数据量
- **How**: 基于数据库状态和文件系统验证的双重检查机制

**恢复流程设计**:
```cpp
class TransferRecoveryManager {
public:
    bool RecoverOnStartup() {
        auto incomplete_tasks = status_db_->GetIncompleteTransfers();
        
        for (const auto& task : incomplete_tasks) {
            // 验证已下载分块
            auto completed_chunks = ValidateDownloadedChunks(task);
            
            // 计算剩余分块
            auto remaining_chunks = CalculateRemainingChunks(task, completed_chunks);
            
            // 恢复传输
            transfer_manager_->ResumeTransfer(task, remaining_chunks);
        }
        return true;
    }
    
private:
    std::vector<int> ValidateDownloadedChunks(const TransferTask& task);
};
```

**验收标准**:
- [ ] 进程重启后自动恢复传输
- [ ] 网络中断后30秒内恢复
- [ ] 分块验证准确率100%
- [ ] 恢复时间<30秒

---

#### 步骤2.3：错误处理和重试机制
**优先级**: 🟡 中 | **预计时间**: 1天 | **风险**: 低

**当前状态分析**:
```cpp
// 现有错误处理 - 简单粗暴
if (ret != ErrorCode::kOk) {
    ERROR("下载失败: %s", file_info.file_path.c_str());
    return;  // 直接放弃，无重试
}
```

**改动内容**:
实现分层错误处理和智能重试策略

**核心改动原因**:
- **Why**: 网络环境不稳定，临时错误应该重试而非放弃
- **What**: 区分临时错误和永久错误，实现指数退避重试
- **How**: 错误分类 + 重试策略 + 失败统计

**重试策略设计**:
```cpp
class ChunkRetryHandler {
public:
    enum class ErrorType { NETWORK_TIMEOUT, DISK_FULL, PERMISSION_DENIED, UNKNOWN };
    
    bool ShouldRetry(ErrorType error_type, int retry_count) {
        switch (error_type) {
            case ErrorType::NETWORK_TIMEOUT:
                return retry_count < 3;  // 网络错误重试3次
            case ErrorType::DISK_FULL:
                return false;  // 磁盘满不重试
            case ErrorType::PERMISSION_DENIED:
                return false;  // 权限错误不重试
            default:
                return retry_count < 1;  // 未知错误重试1次
        }
    }
    
    int CalculateRetryDelay(int retry_count) {
        return std::pow(2, retry_count);  // 指数退避: 1s, 2s, 4s
    }
};
```

**验收标准**:
- [ ] 网络临时错误自动重试
- [ ] 永久错误正确识别不重试
- [ ] 指数退避算法正确实现
- [ ] 重试统计准确记录

---

### 第三阶段：系统集成 (3-4天)

#### 步骤3.1：DockInfoManager集成改造
**优先级**: 🔴 高 | **预计时间**: 2天 | **风险**: 高

**当前状态分析**:
```cpp
// 现有核心逻辑 - dock_info_manager.cc (第156-170行)
void DockInfoManager::OnMediaFileUpdate(const MediaFileInfo& file_info) {
    INFO("收到媒体文件更新: %s, 大小: %zu bytes", 
         file_info.file_name.c_str(), file_info.file_size);
    
    std::vector<uint8_t> file_data;
    auto ret = media_files_reader_->ReadMediaFile(file_info.file_path, file_data);
    
    if (ret == ErrorCode::kOk) {
        std::string local_file_path = "./celestial_works/media/" + file_info.file_name;
        SaveToLocalFile(local_file_path, file_data);
        
        // 更新数据库状态
        media_status_db_->UpdateMediaStatus(file_info.file_path, "downloaded");
    } else {
        ERROR("读取媒体文件失败: %s", file_info.file_path.c_str());
    }
}
```

**改动内容**:
将现有的同步全量下载替换为异步分块传输

**核心改动原因**:
- **Why**: 现有同步下载阻塞主线程，大文件导致系统无响应
- **What**: 改为异步分块传输，主线程立即返回，后台处理
- **How**: 保持接口兼容性，内部实现完全重构

**重构后的实现**:
```cpp
void DockInfoManager::OnMediaFileUpdate(const MediaFileInfo& file_info) {
    INFO("收到媒体文件更新: %s, 大小: %.2f MB", 
         file_info.file_name.c_str(), 
         file_info.file_size / (1024.0 * 1024.0));
    
    // 🔥 关键改动：使用分块传输管理器
    auto transfer_task = chunked_transfer_manager_->CreateTransferTask(file_info);
    
    // 🔥 关键改动：异步执行，避免阻塞主线程
    std::thread([this, transfer_task]() {
        auto result = chunked_transfer_manager_->StartTransfer(transfer_task);
        
        if (result == ErrorCode::kOk) {
            // 更新数据库状态
            media_status_db_->UpdateMediaStatus(transfer_task.file_path, "downloaded");
            
            // 触发后续处理 (如上传到NAS)
            OnTransferCompleted(transfer_task);
        } else {
            ERROR("分块传输失败: %s", transfer_task.file_path.c_str());
        }
    }).detach();
    
    // 🔥 关键改动：立即返回，不阻塞
    INFO("传输任务已创建，异步执行中...");
}
```

**集成要点**:
1. **向后兼容**: 保持现有接口不变
2. **渐进迁移**: 支持新旧逻辑并存，通过配置开关
3. **状态同步**: 确保新的传输状态与现有数据库状态一致

**A/B测试设计**:
```cpp
// 配置开关支持A/B测试
if (config_->GetBool("dock_transfer_config.enable_chunked_transfer", false)) {
    // 新逻辑：分块传输
    return chunked_transfer_manager_->StartTransfer(file_info);
} else {
    // 旧逻辑：全量传输 (保持现有行为)
    return LegacyTransferFile(file_info);
}
```

**验收标准**:
- [ ] 新旧逻辑功能等价
- [ ] A/B测试开关正常工作
- [ ] 异步执行不阻塞主线程
- [ ] 状态数据库同步正确

---

#### 步骤3.2：配置和日志系统集成
**优先级**: 🟡 中 | **预计时间**: 1天 | **风险**: 低

**当前状态分析**:
```cpp
// 现有日志 - 简单输出
INFO("收到媒体文件更新: %s", file_info.file_name.c_str());
ERROR("读取媒体文件失败: %s", file_info.file_path.c_str());
```

**改动内容**:
1. **结构化日志**: 添加传输ID、进度、速度等关键信息
2. **日志级别**: 支持DEBUG级别的详细传输日志
3. **性能指标**: 集成传输速度、成功率等指标

**核心改动原因**:
- **Why**: 现有日志信息不足，故障排查困难
- **What**: 增加结构化日志和性能指标收集
- **How**: 扩展现有日志系统，保持格式一致性

**日志增强示例**:
```cpp
// 传输开始日志
INFO("[TRANSFER_START] 任务ID:%d, 文件:%s, 大小:%.2fMB, 分块数:%d", 
     task_id, file_name.c_str(), size_mb, total_chunks);

// 进度日志 (DEBUG级别)
DEBUG("[TRANSFER_PROGRESS] 任务ID:%d, 进度:%d/%d(%.1f%%), 速度:%.2fMB/s", 
      task_id, completed_chunks, total_chunks, progress_percent, speed_mbps);

// 完成日志
INFO("[TRANSFER_COMPLETE] 任务ID:%d, 耗时:%ds, 平均速度:%.2fMB/s", 
     task_id, duration_seconds, avg_speed_mbps);
```

**验收标准**:
- [ ] 日志格式统一规范
- [ ] 关键事件100%记录
- [ ] 性能指标准确计算
- [ ] 日志级别控制正常

---

### 第四阶段：监控和运维完善 (2-3天)

#### 步骤4.1：心跳监控系统
**优先级**: 🟡 中 | **预计时间**: 1天 | **风险**: 低

**当前状态分析**:
现有系统无任何传输监控机制，无法检测僵尸传输或异常状态

**改动内容**:
实现传输任务心跳监控和自动恢复机制

**核心改动原因**:
- **Why**: 长时间传输可能因各种原因卡死，需要自动检测和恢复
- **What**: 定期检查传输任务状态，自动重启异常任务
- **How**: 后台监控线程 + 数据库心跳时间戳

**监控实现**:
```cpp
class TransferHeartbeatMonitor {
public:
    void StartMonitoring() {
        monitor_thread_ = std::thread([this]() {
            while (running_) {
                CheckStaleTransfers();
                std::this_thread::sleep_for(std::chrono::seconds(30));
            }
        });
    }
    
private:
    void CheckStaleTransfers() {
        // 查找超过60秒无心跳的传输任务
        auto stale_tasks = status_db_->Query(
            "SELECT id FROM transfer_tasks WHERE status='downloading' "
            "AND last_heartbeat < datetime('now', '-60 seconds')"
        );
        
        for (const auto& task : stale_tasks) {
            WARN("检测到僵尸传输任务: %d, 尝试恢复", task.id);
            recovery_manager_->RecoverStaleTransfer(task.id);
        }
    }
};
```

**验收标准**:
- [ ] 僵尸任务检测准确
- [ ] 自动恢复成功率>90%
- [ ] 监控开销<1% CPU

---

#### 步骤4.2：性能指标收集
**优先级**: 🟢 低 | **预计时间**: 1天 | **风险**: 低

**改动内容**:
实现传输性能指标的实时收集和统计

**指标设计**:
```cpp
struct TransferMetrics {
    // 实时指标
    double current_speed_mbps;          // 当前传输速度
    size_t active_transfers_count;      // 活跃传输数量
    double memory_usage_mb;             // 内存使用量
    
    // 累计指标
    size_t total_files_transferred;     // 总传输文件数
    size_t total_bytes_transferred;     // 总传输字节数
    double average_speed_mbps;          // 平均传输速度
    double success_rate_percentage;     // 成功率百分比
    
    // 错误统计
    size_t network_errors_count;        // 网络错误次数
    size_t disk_errors_count;          // 磁盘错误次数
    size_t retry_attempts_count;       // 重试次数
};
```

**验收标准**:
- [ ] 指标计算准确
- [ ] 实时更新正常
- [ ] 历史数据保存完整

---

### 第五阶段：测试和验证 (3-4天)

#### 步骤5.1：单元测试
**优先级**: 🔴 高 | **预计时间**: 2天 | **风险**: 低

**测试范围**:
1. **ChunkedTransferManager**: 分块下载逻辑
2. **TransferStatusDB**: 数据库操作
3. **FileIntegrityValidator**: 完整性验证
4. **TransferRecoveryManager**: 恢复机制

**关键测试用例**:
```cpp
// 测试大文件分块下载
TEST(ChunkedTransferManagerTest, LargeFileDownload) {
    // 模拟100MB文件
    MediaFileInfo large_file{"test_100mb.mp4", 100 * 1024 * 1024};
    
    auto result = transfer_manager_->StartTransfer(large_file);
    EXPECT_EQ(result, ErrorCode::kOk);
    
    // 验证内存使用不超过100MB
    auto memory_usage = GetCurrentMemoryUsage();
    EXPECT_LT(memory_usage, 100 * 1024 * 1024);
}

// 测试网络中断恢复
TEST(TransferRecoveryTest, NetworkInterruptionRecovery) {
    // 开始传输
    auto task_id = StartTestTransfer("test_50mb.mp4");
    
    // 模拟网络中断
    SimulateNetworkInterruption();
    
    // 恢复网络
    RestoreNetwork();
    
    // 验证自动恢复
    WaitForTransferCompletion(task_id, 60);
    EXPECT_TRUE(IsTransferCompleted(task_id));
}
```

**验收标准**:
- [ ] 单元测试覆盖率>90%
- [ ] 所有测试用例通过
- [ ] 性能测试达标

---

#### 步骤5.2：集成测试
**优先级**: 🔴 高 | **预计时间**: 1天 | **风险**: 中

**测试场景**:
1. **端到端传输**: 从DJI SDK到本地文件系统
2. **并发传输**: 多文件同时传输
3. **故障恢复**: 各种异常情况的恢复
4. **长时间运行**: 24小时稳定性测试

**测试脚本示例**:
```bash
#!/bin/bash
# 集成测试脚本

echo "开始集成测试..."

# 测试1: 大文件传输
echo "测试大文件传输 (500MB)..."
./test_large_file_transfer 500MB
if [ $? -eq 0 ]; then
    echo "✅ 大文件传输测试通过"
else
    echo "❌ 大文件传输测试失败"
    exit 1
fi

# 测试2: 网络中断恢复
echo "测试网络中断恢复..."
./test_network_interruption_recovery
if [ $? -eq 0 ]; then
    echo "✅ 网络中断恢复测试通过"
else
    echo "❌ 网络中断恢复测试失败"
    exit 1
fi

echo "所有集成测试通过！"
```

**验收标准**:
- [ ] 端到端功能正常
- [ ] 并发传输稳定
- [ ] 故障恢复可靠
- [ ] 长时间运行无内存泄漏

---

## 风险管理

### 技术风险

| 风险项 | 概率 | 影响 | 缓解措施 |
|--------|------|------|----------|
| **DJI SDK兼容性** | 中 | 高 | 严格遵循官方文档，充分测试 |
| **数据库并发冲突** | 低 | 中 | 使用事务和锁机制 |
| **内存泄漏** | 低 | 高 | 智能指针 + 内存监控 |
| **性能回退** | 中 | 中 | A/B测试 + 性能基准 |

### 回滚策略

每个步骤都设计了回滚方案：

1. **配置回滚**: 通过配置开关快速切换到旧逻辑
2. **数据库回滚**: 数据库schema版本管理，支持降级
3. **代码回滚**: Git分支管理，每个步骤独立提交
4. **功能回滚**: A/B测试框架，实时切换新旧功能

### 监控告警

**关键指标监控**:
- 传输成功率 < 95% → 告警
- 内存使用 > 200MB → 告警  
- 平均传输速度 < 1MB/s → 告警
- 错误率 > 5% → 告警

## 成功指标

### 性能指标

| 指标 | 当前值 | 目标值 | 测量方法 |
|------|--------|--------|----------|
| **传输成功率** | <70% | ≥95% | 连续100个文件测试 |
| **内存使用峰值** | 文件大小级别 | ≤100MB | 500MB文件传输监控 |
| **故障恢复时间** | 无 | ≤30秒 | 网络中断后恢复测试 |
| **CPU使用率** | 35% | ≤20% | 系统资源监控 |

### 业务指标

- **系统稳定性**: 24小时连续运行无崩溃
- **运维效率**: 故障自动恢复率>90%
- **用户体验**: 传输进度可视化，状态实时更新

## 总结

本执行计划采用**渐进式重构**策略，将复杂的大文件下载优化分解为25个可控的小步骤。每个步骤都有明确的：

- **改动原因** (Why): 解决什么问题
- **改动内容** (What): 具体做什么
- **实现方式** (How): 技术实现细节
- **验收标准**: 如何验证成功
- **回滚方案**: 如何快速恢复

通过这种方式，确保在保持系统稳定性的前提下，逐步实现从<70%到≥95%传输成功率的目标，同时将内存使用从文件大小级别降低到固定≤100MB。